<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一个博客</title>
    <url>/2020/11/07/my-first-blog/</url>
    <content><![CDATA[<blockquote>
<p>学习前端以来，拥有的第一个博客，利用github+hexo搭建，此次为第一次上传文章。<br>博客配置指南：<a href="https://www.jianshu.com/p/3a05351a37dc">《Hexo的Next主题详细配置》</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Vue中computed和watch的区别</title>
    <url>/2020/11/09/computedAndMethods/</url>
    <content><![CDATA[<h4 id="computed会基于响应式依赖进行缓存，而watch方法却不会"><a href="#computed会基于响应式依赖进行缓存，而watch方法却不会" class="headerlink" title="computed会基于响应式依赖进行缓存，而watch方法却不会"></a>computed会基于响应式依赖进行缓存，而watch方法却不会</h4><h6 id="示例代码如下："><a href="#示例代码如下：" class="headerlink" title="示例代码如下："></a>示例代码如下：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;初始数据：&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;br &#x2F;&gt;</span><br><span class="line">    &lt;p&gt;computed 1次的数据：&#123;&#123; reverseComputed &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;computed 2次的数据：&#123;&#123; reverseComputed &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;computed 3次的数据：&#123;&#123; reverseComputed &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;br &#x2F;&gt;</span><br><span class="line">    &lt;p&gt;method 1次的数据：&#123;&#123; reverseMethods() &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;method 2次的数据：&#123;&#123; reverseMethods() &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;method 3次的数据：&#123;&#123; reverseMethods() &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cn.vuejs.org&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">      el: &#39;#app&#39;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          msg: &#39;hello world!&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        reverseMethods() &#123;</span><br><span class="line">          console.log(222)</span><br><span class="line">          return this.msg.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        reverseComputed() &#123;</span><br><span class="line">          console.log(111)</span><br><span class="line">          return this.msg.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>结果显示如下<br><img src="/2020/11/09/computedAndMethods/img1.jpg" alt="img1"></li>
<li>使用computed计算属性，“111”只打印了一次，说明后续操作直接调用缓存中的值，使用methods方法，“222”打印了3次，说明每次调用methods方法，都会执行一次该方法</li>
</ul>
<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ul>
<li>如果一个数据依赖多个其他数据（多对一），且只想根据依赖数据得到另外一个数据，此时用computed</li>
<li>如果一个数据改变涉及到多个其他相关操作（一对多），比如调用一个函数，改变其他数据等等，此时使用watch</li>
</ul>
]]></content>
      <categories>
        <category>Vue的学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中新的数据结构：Set()和Map()</title>
    <url>/2020/11/12/setAndMap/</url>
    <content><![CDATA[<h3 id="Set"><a href="#Set" class="headerlink" title="Set()"></a>Set()</h3><h4 id="接收数组参数，没有重复项，可以对数组进行去重"><a href="#接收数组参数，没有重复项，可以对数组进行去重" class="headerlink" title="接收数组参数，没有重复项，可以对数组进行去重"></a>接收数组参数，没有重复项，可以对数组进行去重</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s &#x3D; new Set([1, 1, 2, 3])</span><br><span class="line">let res &#x3D; [...s] </span><br><span class="line">console.log(res)       &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h4 id="API：size-add-delete-hs-clear-forEach"><a href="#API：size-add-delete-hs-clear-forEach" class="headerlink" title="API：size/add/delete/hs/clear/forEach"></a>API：size/add/delete/hs/clear/forEach</h4><h4 id="求并集"><a href="#求并集" class="headerlink" title="求并集"></a>求并集</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; [1, 2, 3];</span><br><span class="line">let b &#x3D; [2, 3, 4];</span><br><span class="line">let c &#x3D; [...a, ...b];</span><br><span class="line">let cc &#x3D; new Set(c);</span><br><span class="line">let res &#x3D; [...cc];</span><br><span class="line">console.log(res)        &#x2F;&#x2F; [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<h4 id="求交集"><a href="#求交集" class="headerlink" title="求交集"></a>求交集</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; [1, 2, 3];</span><br><span class="line">let b &#x3D; [2, 3, 4];</span><br><span class="line">let aa &#x3D; new Set(a);</span><br><span class="line">let bb &#x3D; new Set(b);</span><br><span class="line">let res &#x3D; [...aa].filter(function(item) &#123;</span><br><span class="line">  return bb.has(item)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res)        &#x2F;&#x2F; [2, 3]</span><br></pre></td></tr></table></figure>
<h3 id="Map-WeakMap-：储存键值对的形式的数据，has表，散列"><a href="#Map-WeakMap-：储存键值对的形式的数据，has表，散列" class="headerlink" title="Map()/WeakMap()：储存键值对的形式的数据，has表，散列"></a>Map()/WeakMap()：储存键值对的形式的数据，has表，散列</h3><h4 id="key不能重复，通过set方法设置，get方法获取值"><a href="#key不能重复，通过set方法设置，get方法获取值" class="headerlink" title="key不能重复，通过set方法设置，get方法获取值"></a>key不能重复，通过set方法设置，get方法获取值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map &#x3D; new Map();</span><br><span class="line">map.set(&#39;a&#39;, 1);</span><br><span class="line">map.set(&#39;b&#39;, 2);</span><br><span class="line">console.log(map);       &#x2F;&#x2F; Map(2) &#123;&quot;a&quot; &#x3D;&gt; 1, &quot;b&quot; &#x3D;&gt; 2&#125;</span><br><span class="line">map.get(&#39;a&#39;)            &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<h4 id="WeakMap-不会造成内存泄漏"><a href="#WeakMap-不会造成内存泄漏" class="headerlink" title="WeakMap()不会造成内存泄漏"></a>WeakMap()不会造成内存泄漏</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/12/setAndMap/ceshi/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  

  <script>
    // let a = [1, 2, 3];
    // let b = [2, 3, 4];
    // // let c = [...a, ...b];
    // // let cc = new Set(c);
    // // let res = [...cc];
    // // console.log(res)

    // let aa = new Set(a);
    // let bb = new Set(b);
    // let res = [...aa].filter(function(item) {
    //   return bb.has(item)
    // })
    // console.log(res)

    // let map = new Map();
    // map.set('a', 1);
    // map.set('b', 2);
    // console.log(map);
    // console.log(map.get('a')); 

    // var obj = { foo: "bar", baz: 42 }; 
    // var map = new Map(obj);
    // console.log(map);

    // let obj = new Object();
    // obj.a = 1;
    // console.log(obj.hasOwnProperty('a'))
    // console.log(obj.hasOwnProperty('toSstring'))

    // var arr = ["a", "b", "c"];
    // console.log(arr)
    // console.log(Object.getOwnPropertyNames(arr));


    // var str = "今天天天天气好好";
    // function a(str) {
    //   str = str.replace("天", "*");
    //   if(str.indexOf("天") === -1 ) {
    //     return str
    //   }
    //   return a(str)
    // }
    // // var c = a(str);
    // // console.log(c)
    // // console.log(str)
    // console.log(a(str))

    // var str = "今天天气天天好好";
    //     var result = str.search("天天");
    //     console.log(result);//1

    var a;
    var b = null;
    console.log(Object.prototype.toString.call(a));
    console.log(Object.prototype.toString.call(b));
  </script>
</body>
</html>]]></content>
  </entry>
</search>
